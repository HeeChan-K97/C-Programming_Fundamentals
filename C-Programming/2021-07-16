<포인터의 이해>

주소 값의 저장을 목적으로 선언되는 포인터 변수
: 포인터 변수란 메모리의 주소 값을 저장하기 위한 변수이다.
: 포인터는 변수 형태의 포인터와 상수 형태의 포인터를 어우르는 표현이다.
---------------------------------------------------------------------------------------------------------------------------------------------------------------
ex) 정수 7이 저장된 int형 변수 num을 선언하고 이 변수의 주소 값 저장을 위한 포인터 변수 pnum을 선언하자. 그리고 나서 pnum에 변수 num의 주소 값을 저장하자.

int main(void)
{
  int num=7;
  int * pnum;   //이 변수의 주소 값을 저장하기 위한 포인터 변수 pnum을 선언(포인터 변수의 선언!!)
  pnum = &num;    //그 후 pnum에 num의 주소 값을 저장
  . . . .
}

// pnum   포인터 변수의 이름
// int *   int형 변수의 주조 값을 저장하는 포인터 변수의 선언
pnum = &num;    :     '&' 연산자는 오른쪽에 등장하는 피연산자의 주소 값을 반환하는 연산자이다. 
                       이 상황을 우리는 "표인터 변수 pnum이 int 형 변수 num을 가리킨다" 라고 한다.
---------------------------------------------------------------------------------------------------------------------------------------------------------------
<포인터 변수 선언하기>

기본공식:
type * ptr;
    type형 변수의 주소 값을 저장하는 포인터 변수 ptr의 선언
    = type * type형 포인터
    = type * ptr; type형 포인터 변수 ptr
---------------------------------------------------------------------------------------------------------------------------------------------------------------
<변수의 주소 값을 반환하는 & 연산자>
& 연산자의 피연산자는 변수이어야 하며, 상수는 피연산자가 될 수 없다. 변수의 자료형에 맞지 않는 포인터 변수의 선언은 문제가 될 수 있다.

<포인터가 가리키는 메모리를 참조하는 * 연산자>
* 연산자는 포인터가 가리키는 메모리 공간에 '접근'할 때 사용하는 연산자이다.

*pnum이 의미하는 바는...
  = 포인터 변수 pnum이 가리키는 메모리 공간인 변수 num에 접근을 해서...
  
*pnum=20;
printf("%d", *pnum);

각각 다음과 같이 해석이 된다.
  "포인터 변수 pnum이 가리키는 메모리 공간이 변수 num에 정수 20을 저장해라"
  "포인터 변수 pnum이 가리키는 메모리 공간이 변수 num에 저장된 값을 출력해라"
// pnum도 변수이기 때문에 저장된 값의 변경이 가능하다.  
  
<다양한 포인터 형이 존재하는 이유>
//포인터 형은메모리 공간을 참조하는 기준이 된다. 포인터에 형이 존재하지 않는다면 * 연산을 통한 메모리의 접근은 불가능하다.

<잘못된 초인터의 사용과 널 포인터>

int main(void)
{
  int * ptr;    //포인터 변수 ptr은 쓰레기 값으로 초기화 됨
  *ptr=200;
  . . . .
}

//포인터 변수를 선언만하고 초기화하지 않으면, 포인터 변수는 쓰레기 값으로 초기화 된다. 즉 어디를 가르키는지 모르게 된다.

// 우선 선언만 해 놓고, 이후에 유효한 주소 값을 채워 넣을 생각이라면...

int main(void)
{
  int * ptr1=0;
  int * ptr2=NULL;    //NULL은 사실상 0을 의미함
  . . . .
}
