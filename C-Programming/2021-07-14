Chapter 9.C언어의 핵심, 함수.

전달인자의 유무와 반환 값의 유무에 따라서 함수를 네 개의 형태로 나눕시다.
유형1.전달인자와 반환 값이 있는 유형.    //void ShowAddResult(int num);    인자전달(O), 반환 값(X)
유형2.전달인자는 있지만 반환 값이 없는 유형.    //int ReadNum(void);    인자전달(X), 반환 값(O)
유형3.전달인자는 없지만 반환 값은 있는 유형.
유형4.전달인자와 반환 값이 없는 유형.    //void HowToUseThisProg(void);  인자전달(X), 반환 값(X)
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
return이 지니는 두 가지 의미
1. 함수를 빠져나간다.
2. 값을 반환한다.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
함수의 정의와 그에 따른 원형의 선언
** 컴파일의 진행 방향은 위에서 아래로 진행된다. 어떤 특정한 함수의 정의가 호출분 보다 먼저 나와 있다면 컴파일이 문제 없이 진행 되지만 호출문이 정의보다 먼저 나오게 되면
   컴파일을 진행하는 과정에서 문제가 생긴다.(호출문이 이 함수가 어떤 함수인지 알지 못한다.) 그래서 호출문보다 정의가 먼저 나와야하는데 호출문 전에 컴파일러에게 예고를 해주는 
   문장을 넣어주면 호출문이 정의보다 먼저 나오는 상황에서도 컴파일을 진행 할 수 있다.
   
   int Increment(int n);    //함수의 선언
   
   int main(void)   
   {
      int num=2;
      num=Increment(num);   //함수 호출문
      return 0;
   }
   
   int Increment(int n)   //함수의 정의
   {
      n++;
      return 0;
   }
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
변수의 존재기간과 접근범위 1:지역변수

Local Variables-지역변수:여기서 말하는 지역이란 중괄호에 의해 형성되는 영역을 뜻한다. 따라서 중괄호 내에 선언되는 변수는 모두 지역변수다.
이러한 지역변수는 선언된 지역 내에서만 유효하다는 특성을 지닌다. 지역변수가 들어있는 함수를 빠져나오면 더이상 이 변수는 존재하지 않는다(자동소명 된다.)

** 지역변수는 선언된 지역 내에서만 유효하기 때문에 선언된 지역이 다르면 이름이 같아도 문제가 되지 않는다.
*** 지역변수=자동변수: 선언된 영역을 벗어나면 자동으로 소멸하기 때문에 붙여지기도 하는 이름이다.
* 지역변수는 스택(stack)이라는 메모리 영역에 할당된다.
* 지역변수는 접이세 쌓듯이 할당된다.
* 지역변수는 반복문이나 조건문에도 선언이 가능하다.

매개변수: 지역변수의 일종
** 선언된 함수 내에서만 접근이 가능하다.
** 선언된 함수가 반환을 하면, 지역변수와 마찬가지로 소멸이 된다.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
변수의 존재기간과 접근범위 2:전역변수, static변수, register 변수

이 변수는 프로그램이 처음 실행되면 메모리 공간에 할당되어서 프로그램이 종료될 때까지 메모리 공간에 남아있는 변수이다.

전역변수: 프로그램의 시작과 동시에 메모리 공간에 할당되어 종료 시까지 존재한다.
          별도의 값으로 초기화하지 않으면 0으로 초기화된다.
          프로그램 전체 영역 어디서든 접근이 가능하다.
          
          **전역변수와 지역변수의 이름이 같아도 해당 지역변수가 존재하는 함수내에서는 전역변수가 가려지고 지역변수가 사용된다. 즉, 아무 문제 없다.
          *** 하지만 전역변수를 많이 사용하게 되면 프로그램은 복잡해지고 스파게티 코드가 될 수 있다.
          
Static 지역변수: 1. 선언된 함수 내에서만 접근이 가능하다.
                 2. 딱 1회 초기화되고 프로그램 종료 시까지 메모리 공간에 존재한다.(전역변수 특성)
                 3. 전역변수보다 안정적이다.
                 
                 void SimpleFunc(void)
                 {
                    static int num1=0;    //사실상 존재하지 않는 코드가 된다! 한번 초기화 된 이후.
                    int num2=0;
                    num1++; num2++;
                    printf("static: %d, local: %d \n", num1, num2);
                 }
                 
                 실행결과
                 static: 1, local: 1
                 static: 2, local: 1
                 static: 3, local: 1
                 초기화 된 이후에 사라지니까 num1++; 로 인해서 숫자가 늘어나는 것을 볼 수 있고 num2는 계속 0으로 초기화 되니까 1로만 출력되는 것을 알 수 있다.
                 
                 static으로 선언된 지역변수는 전역변수와 동일한 시기에 할당되고 소멸. 단, 지역변수와 마찬가지로 선언된 함수 내에서만 접근이 가능.
                 프로그램이 실행되는 동안에 계속해서 유지해야 할 변수가 있다면 대부분의 경우 전역변수를 떠올리지만 그 변수에 접근하는 영역이 하나의 함수로
                 제한된다면, 우리는 static 지역변수의 선언을 고려해볼 필요가 있다.
                 
Register 변수: CPU에 존재하는 'register'라는 메모리 공간에 저장될 확률이 높아진다.
               레지스터는 CPU내에 존재하는 그 크기가 매우 작은 메모리이다. 하지만 CPU내에 존재하기 때문에 이 메모리에 저장된 데이터를 대상으로 하는 연산은 매우 빠르다.
               이러한 선언에 최종결정은 컴파일러가 내린다. 아무리 register 선언을 추가해도 컴파일러가 합당하지 않다고 판한다면 레지스터에 할당되지 않는다.
               반대로 아무런 선언을 하지 않아도 컴파일러가 레지스터에 할당해야겠다고 판단하면 그 변수는 레지스터에 할당된다.
               
재귀함수: 함수 내에서 자기 자신을 다시 호출하는 함수.      
          
          void Recursive(void)
          {
            printf("Recursive Call! \n");
            Recursive();
          }
          
          "Recursive 함수를 싱핼하는 중간에 다시 Recursive 함수가 호출되면, Recursive함수의 복사본을 하나 더 만들어서 복사본을 실행하게 된다."
          
재귀함수의 디자인 사례
팩토리얼/ n! = n x (n-1) x (n-2) . . . x 2 x 1
          if(n>=1)
              return n * Factorial(n-1);
--------------------------------------------------------------------------------------------------------------------------------------------------------------------

