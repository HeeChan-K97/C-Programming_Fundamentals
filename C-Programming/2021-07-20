<포인터와 배열의 이해>

배열의 이름은 포인터이며, 그 값을 바꿀 수 있는 상수 형태의 포인터이다.

#include <stdio.h>

int main(void)
{
  int arr[3]={0, 1, 2}
  printf("배열의 이름: %p \n", arr);
  printf("배열의 첫번째 요소: %p \n", &arr[0]);
  printf("배열의 두번째 요소: %p \n", &arr[1]);
  printf("배열의 세번째 요소: %p \n", &arr[2]);
  //arr = &arr[i]; //이 문장은 컴파일 에러를 일으킨다
  
  return 0;
}

실행결과
배열의 이름: 0012FF50
배열의 첫번째 요소: 0012FF50
배열의 두번째 요소: 0012FF54
배열의 세번째 요소: 0012FF58

** int형 배열요소간 주소 값의 차는 4바이트이다.
** 모든 배열요소가 메모리 공간에 나란이 할당된다.
** 배열의 이름은 배열의 시작 주소 값을 의미하며, 그 형태는 값의 저장이 불가능한 상수이다.
    즉, 포인터 변수의 주소 값은 변경이 가능하지만 배열의 이름은 그 주소 값을 변경이 불가능하다.
** 배열의 이름은 상수 형태의 포인터. 배열의 이름을 피연산자로 하는 * 연산이 가능하다.
** 1차원 배열이름의 포인터 형은 배열의 이름이 가리키는 대상을 기준으로 결정하면 된다.

*** 변수의 주소 값을 반환하는 & 연산자
*** 포인터가 가리키는 메모리를 참조하는 * 연산자

<포인터를 배열의 이름처럼 사용할 수도 있다>
배열의 이름과 포인터 변수는 변수냐 상수냐의 특성적 차이가 있을 뿐, 둘 다 포인터이기 때문에 포인터 변수로 할 수 있는 연산은 배열의 이름으로 할 수 있는
연산은 포인터 변수로도 할 수 있다.

int * ptr=&arr[0];
//int* 형 포인터 변수 ptr에 arr[0]에 해당하는 주소를 넣어라(&).
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
<포인터를 대상으로 하는 증가 및 감소 연산>

*int 형 포인터를 대상으로 n 증가         n X sizeof(int) 의 크기만큼 증가
*double 형 포인터를 대상으로 n 증가         n X sizeof(double) 의 크기만큼 증가

*int 형 포인터를 대상으로 n 감소         n X sizeof(int) 의 크기만큼 감소
*double 형 포인터를 대상으로 n 감소         n X sizeof(double) 의 크기만큼 감소

==TYPE형 포인터를 대상으로 n의 크기만큼 값을 증가 및 감소 시, n X sizeof(TYPE)의 크기만큼 주소 값이 증가 및 감소합니다.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
*(++ptr)=20;    //ptr에 저장된 값 자체를 변경
*(ptr+1)=20;    //ptr에 저장된 값은 변경되지 않음
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
printf("%d %d %d \n", *(ptr+0), *(ptr+1), *(ptr+2));
printf("%d %d %d \n", ptr[0], ptr[1], ptr[2]);

printf("%d %d %d \n", *(arr+0), *(arr+1), *(arr+2));
printf("%d %d %d \n", arr[0], arr[1], arr[2]);

위 네 문장은 모두 동일한 출력결과를 보인다.
즉,
          arr[i] == *(arr+i);
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
<상수 형태의 문자열을 기리키는 포인터>
두 가지 형태의 문자열 표현:
char str1[] = "My string";    //배열의 길이는 자동으로 계산
                              //변수 형태의 문자열

char * str2 = "Your String";    //상수 형태의 문자열

<어디서든 선언할 수 있는 상수 형태의 문자열>
상수 형태의 문자열: char * str = "Const String";
위에 문장은 이렇게 해석된다: char * str = 0x1234;

<포인터 변수로 이뤄진 배열: 포인터 배열>
주소 값의 저장이 가능한 배열을 가리켜 포인터 배열이라고 한다.

문자열 배열:   char * strArr[3]={"Simple", "String", "Array"};
큰 따옴표로 묶여서 표현되는 문자열은 그 형태에 상관없이 메모리 공간에 저장된 후 그 주소 값이 반환된다.

즉 위의 문자열 배열을 주소 값으로 표현하자면: char * strArr[3]={0x1004, 0x1048, 0x2012};
결국 포인터 배열은 가리키는 대상의 차이는 있지만, 다른 메모리 공간을 기리킨다는 점에서 동일하다.

----------------------------------------------------------------------Chapter 13 Fin-----------------------------------------------------------------------------
