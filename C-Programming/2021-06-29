상수에 대한 이해

이름을 지니지 않는 상수, Literal

int main(void)
{
  int num = 30 + 40;    //30과 40은 상수이다
  . . . .
}

위의 예시에서 30, 40, 그리고 연산후에 만들어지는 70이라는 상수는 CPU를 거치며 저장이 되는데
그 단계는 이렇다,

1. 정수 30과 40이 메모리 공간에 상수의 형태로 저장된다.
2. 두 상수를 기반으로 덧셈이 진행된다.
3. 덧셈의 결과로 얻어진 정수 70이 변수 num에 저장된다.

Literal 상수의 자료형?

리터럴 상수는,
int형으로 표현 가능한 정수형 상수는 int형으로 메모리 공간에 저장하기로 약속되어 있다.
double형으로 표현 가능한 실수형 상수는 double형으로 저장하기로 약속되어 있다.

하지만, 대입 연산자(operator)의 왼편에 있는 변수의 자료형에 따라서 상수의 자료형이 결정되는 것은 아니다.
-------------------------------------------------------------------------------------------------------------------

접미사(suffix)를 이용한 다양한 상수의 표현

U = unsigned int
L = long
UL = unsigned long
LL = long long
ULL = unsigned long long

F/f = float
L = long double

위의 접미사들은 대소문자를 구분하지 않으므로 사용자의 눈에 잘 띄게 상황에 맞게 사용하면 된다.

<Symbolic Constants = const 상수>

심볼릭 상수는 변수와 마찬가지로 이름을 지니는 상수.
--const 키워드를 사용하는 방법---

int main(void)
{
    const int MAX=100;    //MAX는 상수 따라서 값의 변경 불가!!
    const double PI=3.1415;   //PI는 상수 따라서 값의 변경 불가!!
}

위의 예시처럼 이름을 지니는 상수를 심볼링 상수라고 한다.
일단 초기화되면 그 값을 변경시킬 수 없다. 뿐만 아니라, 선언과 초기화를 분리시킬 수도 없다.

const int MAX;
MAX=100;

위처럼 분리 불가능!
const상수도 일반 변수와 마찬가지로 선언후에 초기화를 하지 않으면 쓰레기 값으로 초기화되어 이후에 값을 변경하려 들 때 컴파일 에러가 발생한다.

상수의 이름은 모두 대문자로 표시하고, 둘 이상의 단어로 연결할 때에는 MY_AGE와 같이 언더바를 이용해서 두 단어를 구분하는 것이 관례이다.
-----------------------------------------------------------------------------------------------------------------------------------------
<자료형의 변환>
자료형의 변환은 데이터의 표현 방식을 바꾸는 것.
* 자동 형 변환(묵시적 형 변환)
* 강제 형 변환(명시적 형 변환)

**실수형 데이터를 정수형 데이터로 변환하는 과정에서는 '소수부의 손실'이 발생한다.
**정수형 데이터를 실수형 데이터로 변환하는 과정에서는 작은 오차가 존재하게 되지만 제일 preferable 하다.
**바이트 크기가 큰 정수를 바이트 크기가 작은 정수로 형 변환하는 경우에는 변환하고자 하는 정수의 
  바이트 크기에 맞춰서 상위 바이트를 단순히 소멸시키고 부호가 바뀔 수 있으니 주의해야 한다.
  
그리하여 정수의 승격(Integral Promotion)을 통해서 자료형의 형을 자동으로 일치 시키는데...

** 피연산자의 자료형이 일치하지 않아서 발생하는 자동 형 변환은 데이터의 손실을 최소화하는 방향으로 진행되고 그 방향은 이렇다,

    int -> long -> long long -> float -> double -> long double
    
** char형 정수와 short형 정수를 대상으로 덧셈연산을 하는 경우에는 char형 정수가 short형 정수로 변환되지 않고 정수의 승경에 의해서 둘 다 int형 정수로 변환된다.
** 반면, float형 데이터가 long long형으로 형 변화될 경우에는 '소수부의 손실'이 발생하기 때문에
   형 변환의 우선순위는 정수 자료형보다 실수 자료형이 무조건 앞서는 형태로 정의되어 있다.

형 변환을 명령하기 위해서는 '형 변환 연산자(type casting Operator)'를 사용.
이 연산자가 제일 먼저 연산된다.

